<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="./threejs/build/three.min.js"></script>

		<script src="./js/renderers/Projector.js"></script>
		 <script src="./js/renderers/CanvasRenderer.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
		<script src="./js/lib/stats.min.js"></script>
		<script src="./js/lib/TrackballControls.js"></script>

		<script>

// 			var container, stats;

// 			var camera, scene, renderer;

// 			var cube, plane;

// 			var targetRotation = 0;
// 			var targetRotationOnMouseDown = 0;

// 			var mouseX = 0;
// 			var mouseXOnMouseDown = 0;

// 			var windowHalfX = window.innerWidth / 2;
// 			var windowHalfY = window.innerHeight / 2;

// 			init();
// 			animate();

// 			function init() {
// 			scene = new THREE.Scene();

// 				container = document.createElement( 'div' );
// 				document.body.appendChild( container );

// 				var info = document.createElement( 'div' );
// 				info.style.position = 'absolute';
// 				info.style.top = '10px';
// 				info.style.width = '100%';
// 				info.style.textAlign = 'center';
// 				info.innerHTML = 'Drag to spin the cube';
// 				container.appendChild( info );

// 			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 * 100 );
// 			camera.position.z =  500;
// 			scene.add( camera );
// 						 var controls = new THREE.OrbitControls( camera );
	
// 				// Cube

// 				var geometry = new THREE.BoxGeometry( 200, 200, 200 );

// 				for ( var i = 0; i < geometry.faces.length; i += 2 ) {

// 					var hex = Math.random() * 0xffffff;
// 					geometry.faces[ i ].color.setHex( hex );
// 					geometry.faces[ i + 1 ].color.setHex( hex );

// 				}

// 				var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );

// 				cube = new THREE.Mesh( geometry, material );
				      
// 				scene.add( cube );

// 				// Plane

// 				var geometry = new THREE.PlaneBufferGeometry( 200, 200 );
// 				geometry.rotateX( - Math.PI / 2 );

// 				var material = new THREE.MeshBasicMaterial( { color: 0xe0e0e0, overdraw: 0.5 } );

// 				plane = new THREE.Mesh( geometry, material );
// 				// scene.add( plane );
                    
// 				renderer = new THREE.CanvasRenderer();
// 				renderer.setClearColor( 0xf0f0f0 );
// 				renderer.setPixelRatio( window.devicePixelRatio );
// 				renderer.setSize( window.innerWidth, window.innerHeight );
// 				container.appendChild( renderer.domElement );

// 				stats = new Stats();
// 				stats.domElement.style.position = 'absolute';
// 				stats.domElement.style.top = '0px';
// 				container.appendChild( stats.domElement );

// 				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
// 				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
// 				document.addEventListener( 'touchmove', onDocumentTouchMove, false );
//                        controls.addEventListener( 'change', render );
// 				//

// 				window.addEventListener( 'resize', onWindowResize, false );

// 			}

// 			function onWindowResize() {

// 				windowHalfX = window.innerWidth / 2;
// 				windowHalfY = window.innerHeight / 2;

// 				camera.aspect = window.innerWidth / window.innerHeight;
// 				camera.updateProjectionMatrix();

// 				renderer.setSize( window.innerWidth, window.innerHeight );

// 			}

// 			//

// 			function onDocumentMouseDown( event ) {

// 				event.preventDefault();

// 				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
// 				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
// 				document.addEventListener( 'mouseout', onDocumentMouseOut, false );

// 				mouseXOnMouseDown = event.clientX - windowHalfX;
// 				targetRotationOnMouseDown = targetRotation;

// 			}

// 			function onDocumentMouseMove( event ) {

// 				mouseX = event.clientX - windowHalfX;

// 				targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;

// 			}

// 			function onDocumentMouseUp( event ) {

// 				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
// 				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
// 				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

// 			}

// 			function onDocumentMouseOut( event ) {

// 				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
// 				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
// 				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

// 			}

// 			function onDocumentTouchStart( event ) {

// 				if ( event.touches.length === 1 ) {

// 					event.preventDefault();

// 					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
// 					targetRotationOnMouseDown = targetRotation;

// 				}

// 			}

// 			function onDocumentTouchMove( event ) {

// 				if ( event.touches.length === 1 ) {

// 					event.preventDefault();

// 					mouseX = event.touches[ 0 ].pageX - windowHalfX;
// 					targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

// 				}

// 			}

// 			//

// 			function animate() {

// 				requestAnimationFrame( animate );
//                    plane.rotation.y = cube.rotation.y += ( targetRotation - cube.rotation.y ) * 0.05;
// 				render();
// 				stats.update();
// 				// controls.update();

// 			}

// 			function render() {
// newZ = -(camera.position.x * Math.cos(5.49779)) - (camera.position.z * Math.sin(5.49779));
// newX = (camera.position.x * Math.cos(0.78)) + (camera.position.z * Math.sin(0.78));
// 				renderer.render( scene, camera );
// 			}

// GLOBALS
var container, scene, camera, renderer, projector, stats, planes, gui, controls;
var interesectedObject, interesected = false, clicked = false;

function init() {   
    // if (!Detector.webgl) Detector.addGetWebGLMessage();
    
    // SCENE
    scene = new THREE.Scene();    
    
    // CAMERA
    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20000);    
    camera.position.set( 0, 100, 750 );
    scene.add(camera);    
    
    // RENDERER
    // if ( Detector.webgl) {
		renderer = new THREE.WebGLRenderer( {antialias:true} );
  //   } else {
		// renderer = new THREE.CanvasRenderer(); 
  //   }
    
    // CONTAINER
    container = document.createElement('div');
	document.body.appendChild(container);    
    container.appendChild(renderer.domElement);
    
    var info = document.createElement( 'div' );
		info.style.position = 'absolute';
		info.style.top = '5px';
		info.style.width = '100%';
		info.style.textAlign = 'center';
		info.innerHTML = '<a href="http://djankey.tumblr.com/" target="_blank">djankey</a>';
	container.appendChild(info);
    
    // POINT LIGHT   
    var light = new THREE.PointLight(0xff0000);
	light.position.set(500, 500, 0);
	scene.add(light);   

    // AMBIEND LIGHT
    var ambientLight = new THREE.AmbientLight(0xffffff);
    scene.add(ambientLight);  
   
    
    // AXIS
    var axes = new THREE.AxisHelper(500);
	scene.add(axes);    
    
    // GROUP
    group = new THREE.Object3D();
    scene.add(group);
    
    // CUBES
    var geometry = new THREE.CubeGeometry(200, 200, 200);
    geometry.faces[0].color.setHex( 0x890202 );
    geometry.faces[1].color.setHex( 0x890202 );
    geometry.faces[2].color.setHex( 0x9e0208 );
    geometry.faces[3].color.setHex( 0x9e0208 );
    geometry.faces[4].color.setHex( 0xFF0000 );
    geometry.faces[5].color.setHex( 0x333333 ); 
    
    var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors } );
    
    // for ( var i = 0; i < 4; i ++ ) {
        var object = new THREE.Mesh( geometry, material );		
        object.position.x = 0;
        object.position.z = 0 ;    
        object.rotation.y = 0;
        
        group.add( object );
    // }   
    
    // TweenLite.to(group.rotation, 3, {x:Math.PI, y:Math.PI, z:Math.PI});    
    
    // PROJECTOR
    projector = new THREE.Projector();
    
    // STATS
    stats = new Stats();
	stats.domElement.style.position = 'absolute';	
    stats.domElement.style.top = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );    
    
    // MOUSE CONTROLS
    controls = new THREE.TrackballControls(camera, renderer.domElement);
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('mouseup', onDocumentMouseUp, false);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('mouseout', onDocumentMouseOut, false);
    
    // RESIZE
    window.addEventListener('resize', resizeHandler, false);
    resizeHandler();
    
    // ANIMATE
    animate();
}

function onDocumentMouseDown(event) { 
    event.preventDefault();
    clicked = true;
    
    var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
	projector.unprojectVector( vector, camera );
    var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
    var intersects = raycaster.intersectObjects( group.children );
    
    if ( intersects.length > 0 ) {
        interesected = true;
        intersects[ 0 ].object.position.y +=10;       
    }
}

function onDocumentMouseUp(event) { 
    event.preventDefault();
    clicked = false;
}

function onDocumentMouseOut(event) { 
    event.preventDefault();
    clicked = false;
    interesected = false;
    if(interesectedObject) selectObject(interesectedObject, false); 
    interesectedObject = null;
}

function onDocumentMouseMove(event) {
    event.preventDefault();
    
    var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
	projector.unprojectVector( vector, camera );
    var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
    var intersects = raycaster.intersectObjects( group.children );
    
    if(interesectedObject) selectObject(interesectedObject, false); 
    interesectedObject = null;
    
    if ( intersects.length > 0 ) {
        interesectedObject = intersects[0].object;        
        selectObject(interesectedObject, true);       
        interesected = true;      
    } else {
        interesected = false;      
    }
}

function selectObject(obj, e) {
    if(obj) {
        if(e===true) {
            TweenLite.to(interesectedObject.scale, 0.5, {x:1.4, y:1.4, z:1.4});
        } else {
            TweenLite.to(interesectedObject.scale, 0.5, {x:1, y:1, z:1});
        }        
    }
}

function resizeHandler() {
   camera.aspect = window.innerWidth / window.innerHeight;
   camera.updateProjectionMatrix();
   renderer.setSize(window.innerWidth, window.innerHeight);
   controls.handleResize();    
   render();
}

function animate() {
    requestAnimationFrame(animate);
    stats.update();
  
    if(interesected === false || clicked === false) {
        if(controls.enabled===false) controls.enabled = true;
    }  else {
        if(controls.enabled===true) controls.enabled = false;
    }
    
    controls.update();    
    render();
}

function render() {
    renderer.render( scene, camera ); 
}


// Init
window.addEventListener('load', init, false);
		</script>

	</body>
</html>
